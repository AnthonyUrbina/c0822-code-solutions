- get requests are made to load the inital screen
- hash route is set to #sign in
- page renders (is a controlled form)
- componentDidMount gets triggered and kicks off the hashchange add event listener on window


1. User can sign up
- when a hashchange to #sign-up is detected, a re-render is triggered
- a new controlled form loads, it's values are being kept track of via the onChange event
- these values are then used to update the username and password properties of the state
- once the 'Register' button is clicked, an onSubmit event is fired, triggering the handleSubmit callback
  - in the callback a fetch request is made to 'api/auth/${action}' (in this case ${action} is 'sign-up')
- our backend at server/index.js receives the POST request on line 27
  - if username or password equate to null values then the request gets thrown
  - and the client recieves an error message
  - else, the password gets hashed by argon2.hash(), which returns a promise.
    - then ðŸ˜‰ we query our database using params (we never use raw user data for db queries)
      - in this query we are inserting the username and password(hashed) that were sent to us by the client into our users tabls
      - we are also returning userId, username, and createdAt columns for the values we just created
    - and since we are returning the result of db.query(sql, params), we don't need to catch it
    - bc if it fails, the promise of it's then will be deemed rejected if it's return value is an error
    - then ðŸ˜‰ the successful result of the db query is stringified then sent to the client along w a 201 'created successfully' status code
    - any errors are caught with next(err) and passed to the errorMiddleware
- back on the client side
  - the fetch was made
  - then ðŸ˜‰ the response body is received and parsed
  - then ðŸ˜‰ we check to see if the "action" was a 'signup'
    - if true, then we set the hash to 'sign-in'
  - since hash was changed, the 'hashchange' event gets triggered which calls for a re-render to the 'sign-in' view

2. User can sign in
- once the re-render is triggered, a new controlled form loads, it's input values are tracked via the onChange event
- these values are then used to update the username and password properties of the state
- once the 'Log In' button is clicked, an onSubmit event is fired, triggering the handleSubmit callback
  - in the callback a fetch request is made to 'api/auth/${action}' (in this case ${action} is 'sign-in')
- our backend at server/index.js receives the POST request on line 50
  - if username or password equate to null values then the request gets thrown
  - and the client recieves an error message
  - else we query our database using params (we never use raw data for db queries)
    - in this query we are selecting the "userId", "hashedPassword" from the users table, but only for the username property of the req body
    - then ðŸ˜‰ if the username we queried for does not exist, we throw an error and send a 401 'invalid login' response to the user
    - else we use argon2.verify(hashedPassword, password) to check if the salt + password result in the correct hashedPassword
      - then ðŸ˜‰ if
